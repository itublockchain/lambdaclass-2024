import { Proof } from '../../proof-system/zkprogram.js';
import { MerkleList, MerkleListIterator } from '../../provable/merkle-list.js';
import { IndexedMerkleMapBase } from '../../provable/merkle-tree-indexed.js';
import { SelfProof } from '../../proof-system/zkprogram.js';
import { Provable } from '../../provable/provable.js';
import { MerkleLeaf } from './offchain-state-serialization.js';
export { OffchainStateRollup, OffchainStateCommitments };
declare const OffchainStateCommitments_base: (new (value: {
    root: import("../../provable/field.js").Field;
    actionState: import("../../provable/field.js").Field;
}) => {
    root: import("../../provable/field.js").Field;
    actionState: import("../../provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("../../provable/types/provable-intf.js").Provable<{
    root: import("../../provable/field.js").Field;
    actionState: import("../../provable/field.js").Field;
}, {
    root: bigint;
    actionState: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("../../provable/field.js").Field[]) => {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        root: string | number | bigint | import("../../provable/field.js").Field;
        actionState: string | number | bigint | import("../../provable/field.js").Field;
    }) => {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    };
    toInput: (x: {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    }) => {
        fields?: import("../../provable/field.js").Field[] | undefined;
        packed?: [import("../../provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    }) => {
        root: string;
        actionState: string;
    };
    fromJSON: (x: {
        root: string;
        actionState: string;
    }) => {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    };
    empty: () => {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    };
};
/**
 * Commitments that keep track of the current state of an offchain Merkle tree constructed from actions.
 * Intended to be stored on-chain.
 *
 * Fields:
 * - `root`: The root of the current Merkle tree
 * - `actionState`: The hash pointing to the list of actions that have been applied to form the current Merkle tree
 */
declare class OffchainStateCommitments extends OffchainStateCommitments_base {
    static emptyFromHeight(height: number): OffchainStateCommitments;
}
/**
 * This program represents a proof that we can go from OffchainStateCommitments A -> B
 */
declare function OffchainStateRollup({ 
/**
 * the constraints used in one batch proof with a height-31 tree are:
 *
 * 1967*A + 87*A*U + 2
 *
 * where A = maxActionsPerProof and U = maxActionsPerUpdate.
 *
 * To determine defaults, we set U=4 which should cover most use cases while ensuring
 * that the main loop which is independent of U dominates.
 *
 * Targeting ~50k constraints, to leave room for recursive verification, yields A=22.
 */
maxActionsPerProof, maxActionsPerUpdate, logTotalCapacity, }?: {
    maxActionsPerProof?: number | undefined;
    maxActionsPerUpdate?: number | undefined;
    logTotalCapacity?: number | undefined;
}): {
    Proof: {
        new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
            proof: unknown;
            publicInput: OffchainStateCommitments;
            publicOutput: OffchainStateCommitments;
            maxProofsVerified: 0 | 2 | 1;
        }): {
            verify(): void;
            verifyIf(condition: import("../../provable/bool.js").Bool): void;
            publicInput: OffchainStateCommitments;
            publicOutput: OffchainStateCommitments;
            proof: unknown;
            maxProofsVerified: 0 | 2 | 1;
            shouldVerify: import("../../provable/bool.js").Bool;
            toJSON(): import("../../proof-system/zkprogram.js").JsonProof;
        };
        publicInputType: typeof OffchainStateCommitments;
        publicOutputType: typeof OffchainStateCommitments;
        tag: () => {
            name: string;
            publicInputType: typeof OffchainStateCommitments;
            publicOutputType: typeof OffchainStateCommitments;
        };
        fromJSON<S extends (new (...args: any) => Proof<unknown, unknown>) & {
            prototype: Proof<any, any>;
            fromJSON: typeof Proof.fromJSON;
            dummy: typeof Proof.dummy;
            publicInputType: import("../../provable/types/struct.js").FlexibleProvablePure<any>;
            publicOutputType: import("../../provable/types/struct.js").FlexibleProvablePure<any>;
            tag: () => {
                name: string;
            };
        } & {
            prototype: Proof<unknown, unknown>;
        }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("../../proof-system/zkprogram.js").JsonProof): Promise<Proof<import("../../provable/types/provable-derivers.js").InferProvable<S["publicInputType"]>, import("../../provable/types/provable-derivers.js").InferProvable<S["publicOutputType"]>>>;
        dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 2 | 1, domainLog2?: number): Promise<Proof<Input, OutPut>>;
    };
    program: {
        name: string;
        compile: (options?: {
            cache?: import("../../proof-system/cache.js").Cache | undefined;
            forceRecompile?: boolean | undefined;
        } | undefined) => Promise<{
            verificationKey: {
                data: string;
                hash: import("../../provable/field.js").Field;
            };
        }>;
        verify: (proof: Proof<OffchainStateCommitments, OffchainStateCommitments>) => Promise<boolean>;
        digest: () => Promise<string>;
        analyzeMethods: () => Promise<{
            firstBatch: {
                rows: number;
                digest: string;
                gates: import("../../../snarky.js").Gate[];
                publicInputSize: number;
                print(): void;
                summary(): Partial<Record<import("../../../snarky.js").GateType | "Total rows", number>>;
            };
            nextBatch: {
                rows: number;
                digest: string;
                gates: import("../../../snarky.js").Gate[];
                publicInputSize: number;
                print(): void;
                summary(): Partial<Record<import("../../../snarky.js").GateType | "Total rows", number>>;
            };
        }>;
        publicInputType: typeof OffchainStateCommitments;
        publicOutputType: typeof OffchainStateCommitments;
        privateInputTypes: {
            firstBatch: [import("../../provable/crypto/poseidon.js").ProvableHashable<MerkleListIterator<MerkleList<{
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                usesPreviousValue: import("../../provable/bool.js").Bool;
                previousValue: import("../../provable/field.js").Field;
                prefix: import("../../provable/types/unconstrained.js").Unconstrained<import("../../provable/field.js").Field[]>;
            }>>>, Provable<IndexedMerkleMapBase, {
                root: bigint;
                length: bigint;
                data: import("../../provable/types/unconstrained.js").Unconstrained<{
                    nodes: (bigint | undefined)[][];
                    sortedLeaves: {
                        readonly value: bigint;
                        readonly key: bigint;
                        readonly nextKey: bigint;
                        readonly index: number;
                    }[];
                }>;
            }>];
            nextBatch: [import("../../provable/crypto/poseidon.js").ProvableHashable<MerkleListIterator<MerkleList<{
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                usesPreviousValue: import("../../provable/bool.js").Bool;
                previousValue: import("../../provable/field.js").Field;
                prefix: import("../../provable/types/unconstrained.js").Unconstrained<import("../../provable/field.js").Field[]>;
            }>>>, Provable<IndexedMerkleMapBase, {
                root: bigint;
                length: bigint;
                data: import("../../provable/types/unconstrained.js").Unconstrained<{
                    nodes: (bigint | undefined)[][];
                    sortedLeaves: {
                        readonly value: bigint;
                        readonly key: bigint;
                        readonly nextKey: bigint;
                        readonly index: number;
                    }[];
                }>;
            }>, typeof SelfProof];
        };
        rawMethods: {
            firstBatch: (publicInput: OffchainStateCommitments, ...args: [MerkleListIterator<MerkleList<{
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                usesPreviousValue: import("../../provable/bool.js").Bool;
                previousValue: import("../../provable/field.js").Field;
                prefix: import("../../provable/types/unconstrained.js").Unconstrained<import("../../provable/field.js").Field[]>;
            }>>, IndexedMerkleMapBase] & any[]) => Promise<OffchainStateCommitments>;
            nextBatch: (publicInput: OffchainStateCommitments, ...args: [MerkleListIterator<MerkleList<{
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                usesPreviousValue: import("../../provable/bool.js").Bool;
                previousValue: import("../../provable/field.js").Field;
                prefix: import("../../provable/types/unconstrained.js").Unconstrained<import("../../provable/field.js").Field[]>;
            }>>, IndexedMerkleMapBase, SelfProof<unknown, unknown>] & any[]) => Promise<OffchainStateCommitments>;
        };
    } & {
        firstBatch: (publicInput: OffchainStateCommitments, ...args: [MerkleListIterator<MerkleList<{
            key: import("../../provable/field.js").Field;
            value: import("../../provable/field.js").Field;
            usesPreviousValue: import("../../provable/bool.js").Bool;
            previousValue: import("../../provable/field.js").Field;
            prefix: import("../../provable/types/unconstrained.js").Unconstrained<import("../../provable/field.js").Field[]>;
        }>>, IndexedMerkleMapBase] & any[]) => Promise<Proof<OffchainStateCommitments, OffchainStateCommitments>>;
        nextBatch: (publicInput: OffchainStateCommitments, ...args: [MerkleListIterator<MerkleList<{
            key: import("../../provable/field.js").Field;
            value: import("../../provable/field.js").Field;
            usesPreviousValue: import("../../provable/bool.js").Bool;
            previousValue: import("../../provable/field.js").Field;
            prefix: import("../../provable/types/unconstrained.js").Unconstrained<import("../../provable/field.js").Field[]>;
        }>>, IndexedMerkleMapBase, SelfProof<unknown, unknown>] & any[]) => Promise<Proof<OffchainStateCommitments, OffchainStateCommitments>>;
    };
    compile(): Promise<{
        verificationKey: {
            data: string;
            hash: import("../../provable/field.js").Field;
        };
    } | undefined>;
    prove(tree: {
        root: import("../../provable/field.js").Field;
        length: import("../../provable/field.js").Field;
        readonly height: number;
        readonly data: import("../../provable/types/unconstrained.js").Unconstrained<{
            readonly nodes: (bigint | undefined)[][];
            readonly sortedLeaves: {
                readonly value: bigint;
                readonly key: bigint;
                readonly nextKey: bigint;
                readonly index: number;
            }[];
        }>;
        clone(): IndexedMerkleMapBase;
        overwrite(other: IndexedMerkleMapBase): void;
        overwriteIf(condition: boolean | import("../../provable/bool.js").Bool, other: IndexedMerkleMapBase): void;
        insert(key: bigint | import("../../provable/field.js").Field, value: bigint | import("../../provable/field.js").Field): void;
        update(key: bigint | import("../../provable/field.js").Field, value: bigint | import("../../provable/field.js").Field): import("../../provable/field.js").Field;
        set(key: bigint | import("../../provable/field.js").Field, value: bigint | import("../../provable/field.js").Field): import("../../provable/option.js").Option<import("../../provable/field.js").Field, bigint>;
        get(key: bigint | import("../../provable/field.js").Field): import("../../provable/field.js").Field;
        getOption(key: bigint | import("../../provable/field.js").Field): import("../../provable/option.js").Option<import("../../provable/field.js").Field, bigint>;
        assertIncluded(key: bigint | import("../../provable/field.js").Field, message?: string | undefined): void;
        assertNotIncluded(key: bigint | import("../../provable/field.js").Field, message?: string | undefined): void;
        isIncluded(key: bigint | import("../../provable/field.js").Field): import("../../provable/bool.js").Bool;
        _proveInclusion(leaf: import("../../provable/merkle-tree-indexed.js").Leaf, message?: string | undefined): {
            witness: import("../../provable/field.js").Field[];
            index: import("../../provable/bool.js").Bool[];
        };
        _proveInclusionIf(condition: import("../../provable/bool.js").Bool, leaf: import("../../provable/merkle-tree-indexed.js").Leaf, message?: string | undefined): void;
        _proveEmpty(index: import("../../provable/bool.js").Bool[]): {
            witness: import("../../provable/field.js").Field[];
            index: import("../../provable/bool.js").Bool[];
        };
        _proveInclusionOrEmpty(condition: import("../../provable/bool.js").Bool, index: import("../../provable/bool.js").Bool[], leaf: {
            key: import("../../provable/field.js").Field;
            value: import("../../provable/field.js").Field;
            nextKey: import("../../provable/field.js").Field;
        }, message?: string | undefined): {
            witness: import("../../provable/field.js").Field[];
            index: import("../../provable/bool.js").Bool[];
        };
        _proveUpdate(leaf: {
            key: import("../../provable/field.js").Field;
            value: import("../../provable/field.js").Field;
            nextKey: import("../../provable/field.js").Field;
        }, path: {
            index: import("../../provable/bool.js").Bool[];
            witness: import("../../provable/field.js").Field[];
        }): import("../../provable/field.js").Field;
        _computeRoot(node: import("../../provable/field.js").Field, index: import("../../provable/bool.js").Bool[] | import("../../provable/types/unconstrained.js").Unconstrained<number>, witness?: import("../../provable/field.js").Field[] | undefined): {
            root: import("../../provable/field.js").Field;
            path: {
                witness: import("../../provable/field.js").Field[];
                index: import("../../provable/bool.js").Bool[];
            };
        };
        _findLeaf(key_: bigint | import("../../provable/field.js").Field): {
            low: {
                value: bigint;
                key: bigint;
                nextKey: bigint;
                index: import("../../provable/types/unconstrained.js").Unconstrained<number>;
                sortedIndex: import("../../provable/types/unconstrained.js").Unconstrained<number>;
            };
            self: {
                value: bigint;
                key: bigint;
                nextKey: bigint;
                index: import("../../provable/types/unconstrained.js").Unconstrained<number>;
                sortedIndex: import("../../provable/types/unconstrained.js").Unconstrained<number>;
            };
        };
        _setLeafUnconstrained(leafExists: boolean | import("../../provable/bool.js").Bool, leaf: import("../../provable/merkle-tree-indexed.js").Leaf): void;
    }, actions: MerkleList<MerkleList<MerkleLeaf>>): Promise<{
        proof: Proof<OffchainStateCommitments, OffchainStateCommitments>;
        tree: {
            root: import("../../provable/field.js").Field;
            length: import("../../provable/field.js").Field;
            readonly height: number;
            readonly data: import("../../provable/types/unconstrained.js").Unconstrained<{
                readonly nodes: (bigint | undefined)[][];
                readonly sortedLeaves: {
                    readonly value: bigint;
                    readonly key: bigint;
                    readonly nextKey: bigint;
                    readonly index: number;
                }[];
            }>;
            clone(): IndexedMerkleMapBase;
            overwrite(other: IndexedMerkleMapBase): void;
            overwriteIf(condition: boolean | import("../../provable/bool.js").Bool, other: IndexedMerkleMapBase): void;
            insert(key: bigint | import("../../provable/field.js").Field, value: bigint | import("../../provable/field.js").Field): void;
            update(key: bigint | import("../../provable/field.js").Field, value: bigint | import("../../provable/field.js").Field): import("../../provable/field.js").Field;
            set(key: bigint | import("../../provable/field.js").Field, value: bigint | import("../../provable/field.js").Field): import("../../provable/option.js").Option<import("../../provable/field.js").Field, bigint>;
            get(key: bigint | import("../../provable/field.js").Field): import("../../provable/field.js").Field;
            getOption(key: bigint | import("../../provable/field.js").Field): import("../../provable/option.js").Option<import("../../provable/field.js").Field, bigint>;
            assertIncluded(key: bigint | import("../../provable/field.js").Field, message?: string | undefined): void;
            assertNotIncluded(key: bigint | import("../../provable/field.js").Field, message?: string | undefined): void;
            isIncluded(key: bigint | import("../../provable/field.js").Field): import("../../provable/bool.js").Bool;
            _proveInclusion(leaf: import("../../provable/merkle-tree-indexed.js").Leaf, message?: string | undefined): {
                witness: import("../../provable/field.js").Field[];
                index: import("../../provable/bool.js").Bool[];
            };
            _proveInclusionIf(condition: import("../../provable/bool.js").Bool, leaf: import("../../provable/merkle-tree-indexed.js").Leaf, message?: string | undefined): void;
            _proveEmpty(index: import("../../provable/bool.js").Bool[]): {
                witness: import("../../provable/field.js").Field[];
                index: import("../../provable/bool.js").Bool[];
            };
            _proveInclusionOrEmpty(condition: import("../../provable/bool.js").Bool, index: import("../../provable/bool.js").Bool[], leaf: {
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                nextKey: import("../../provable/field.js").Field;
            }, message?: string | undefined): {
                witness: import("../../provable/field.js").Field[];
                index: import("../../provable/bool.js").Bool[];
            };
            _proveUpdate(leaf: {
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                nextKey: import("../../provable/field.js").Field;
            }, path: {
                index: import("../../provable/bool.js").Bool[];
                witness: import("../../provable/field.js").Field[];
            }): import("../../provable/field.js").Field;
            _computeRoot(node: import("../../provable/field.js").Field, index: import("../../provable/bool.js").Bool[] | import("../../provable/types/unconstrained.js").Unconstrained<number>, witness?: import("../../provable/field.js").Field[] | undefined): {
                root: import("../../provable/field.js").Field;
                path: {
                    witness: import("../../provable/field.js").Field[];
                    index: import("../../provable/bool.js").Bool[];
                };
            };
            _findLeaf(key_: bigint | import("../../provable/field.js").Field): {
                low: {
                    value: bigint;
                    key: bigint;
                    nextKey: bigint;
                    index: import("../../provable/types/unconstrained.js").Unconstrained<number>;
                    sortedIndex: import("../../provable/types/unconstrained.js").Unconstrained<number>;
                };
                self: {
                    value: bigint;
                    key: bigint;
                    nextKey: bigint;
                    index: import("../../provable/types/unconstrained.js").Unconstrained<number>;
                    sortedIndex: import("../../provable/types/unconstrained.js").Unconstrained<number>;
                };
            };
            _setLeafUnconstrained(leafExists: boolean | import("../../provable/bool.js").Bool, leaf: import("../../provable/merkle-tree-indexed.js").Leaf): void;
        };
        nProofs: number;
    }>;
};
