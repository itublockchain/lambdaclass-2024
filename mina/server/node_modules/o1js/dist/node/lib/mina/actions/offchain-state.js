import { fetchMerkleLeaves, fetchMerkleMap, fromActionWithoutHashes, toAction, toKeyHash, } from './offchain-state-serialization.js';
import { Field } from '../../provable/wrapped.js';
import { OffchainStateCommitments, OffchainStateRollup, } from './offchain-state-rollup.js';
import { Option } from '../../provable/option.js';
import { assert } from '../../provable/gadgets/common.js';
import { State } from '../state.js';
import { Actions } from '../account-update.js';
import { Provable } from '../../provable/provable.js';
import { Poseidon } from '../../provable/crypto/poseidon.js';
import { smartContractContext } from '../smart-contract-context.js';
import { IndexedMerkleMap } from '../../provable/merkle-tree-indexed.js';
export { OffchainState, OffchainStateCommitments };
/**
 * Offchain state for a `SmartContract`.
 *
 * ```ts
 * // declare your offchain state
 *
 * const offchainState = OffchainState({
 *   accounts: OffchainState.Map(PublicKey, UInt64),
 *   totalSupply: OffchainState.Field(UInt64),
 * });
 *
 * // use it in a contract, by adding an onchain state field of type `OffchainStateCommitments`
 *
 * class MyContract extends SmartContract {
 *  \@state(OffchainStateCommitments) offchainState = State(
 *    OffchainStateCommitments.empty()
 *   );
 *
 *   // ...
 * }
 *
 * // set the contract instance
 *
 * let contract = new MyContract(address);
 * offchainState.setContractInstance(contract);
 * ```
 *
 * See the individual methods on `offchainState` for more information on usage.
 */
function OffchainState(config, options) {
    // read options
    let { logTotalCapacity = 30, maxActionsPerUpdate = 4, maxActionsPerProof, } = options ?? {};
    const height = logTotalCapacity + 1;
    class IndexedMerkleMapN extends IndexedMerkleMap(height) {
    }
    // setup internal state of this "class"
    let internal = {
        _contract: undefined,
        _merkleMap: undefined,
        _valueMap: undefined,
        get contract() {
            assert(internal._contract !== undefined, 'Must call `setContractInstance()` first');
            return internal._contract;
        },
    };
    const onchainActionState = async () => {
        let actionState = (await internal.contract.offchainState.fetch())
            ?.actionState;
        assert(actionState !== undefined, 'Could not fetch action state');
        return actionState;
    };
    const merkleMaps = async () => {
        if (internal._merkleMap !== undefined && internal._valueMap !== undefined) {
            return { merkleMap: internal._merkleMap, valueMap: internal._valueMap };
        }
        let actionState = await onchainActionState();
        let { merkleMap, valueMap } = await fetchMerkleMap(height, internal.contract, actionState);
        internal._merkleMap = merkleMap;
        internal._valueMap = valueMap;
        return { merkleMap, valueMap };
    };
    let rollup = OffchainStateRollup({
        logTotalCapacity,
        maxActionsPerProof,
        maxActionsPerUpdate,
    });
    function contract() {
        let ctx = smartContractContext.get();
        assert(ctx !== null, 'Offchain state methods must be called within a contract method');
        assert(ctx.this.constructor === internal.contract.constructor, 'Offchain state methods can only be called on the same contract that you called setContractInstance() on');
        return ctx.this;
    }
    /**
     * generic get which works for both fields and maps
     */
    async function get(key, valueType) {
        // get onchain merkle root
        let stateRoot = contract().offchainState.getAndRequireEquals().root;
        // witness the merkle map & anchor against the onchain root
        let map = await Provable.witnessAsync(IndexedMerkleMapN.provable, async () => (await merkleMaps()).merkleMap);
        map.root.assertEquals(stateRoot, 'root mismatch');
        // get the value hash
        let valueHash = map.getOption(key);
        // witness the full value
        const optionType = Option(valueType);
        let value = await Provable.witnessAsync(optionType, async () => {
            let { valueMap } = await merkleMaps();
            let valueFields = valueMap.get(key.toBigInt());
            if (valueFields === undefined) {
                return optionType.none();
            }
            let value = fromActionWithoutHashes(valueType, valueFields);
            return optionType.from(value);
        });
        // assert that the value hash matches the value, or both are none
        let hashMatches = Poseidon.hashPacked(valueType, value.value).equals(valueHash.value);
        let bothNone = value.isSome.or(valueHash.isSome).not();
        assert(hashMatches.or(bothNone), 'value hash mismatch');
        return value;
    }
    function field(index, type) {
        const prefix = Field(index);
        let optionType = Option(type);
        return {
            overwrite(value) {
                // serialize into action
                let action = toAction({
                    prefix,
                    keyType: undefined,
                    valueType: type,
                    key: undefined,
                    value: type.fromValue(value),
                });
                // push action on account update
                let update = contract().self;
                update.body.actions = Actions.pushEvent(update.body.actions, action);
            },
            update({ from, to }) {
                // serialize into action
                let action = toAction({
                    prefix,
                    keyType: undefined,
                    valueType: type,
                    key: undefined,
                    value: type.fromValue(to),
                    previousValue: optionType.fromValue(from),
                });
                // push action on account update
                let update = contract().self;
                update.body.actions = Actions.pushEvent(update.body.actions, action);
            },
            async get() {
                let key = toKeyHash(prefix, undefined, undefined);
                return await get(key, type);
            },
        };
    }
    function map(index, keyType, valueType) {
        const prefix = Field(index);
        let optionType = Option(valueType);
        return {
            overwrite(key, value) {
                // serialize into action
                let action = toAction({
                    prefix,
                    keyType,
                    valueType,
                    key,
                    value: valueType.fromValue(value),
                });
                // push action on account update
                let update = contract().self;
                update.body.actions = Actions.pushEvent(update.body.actions, action);
            },
            update(key, { from, to }) {
                // serialize into action
                let action = toAction({
                    prefix,
                    keyType,
                    valueType,
                    key,
                    value: valueType.fromValue(to),
                    previousValue: optionType.fromValue(from),
                });
                // push action on account update
                let update = contract().self;
                update.body.actions = Actions.pushEvent(update.body.actions, action);
            },
            async get(key) {
                let keyHash = toKeyHash(prefix, keyType, key);
                return await get(keyHash, valueType);
            },
        };
    }
    return {
        setContractInstance(contract) {
            internal._contract = contract;
        },
        async compile() {
            await rollup.compile();
        },
        async createSettlementProof() {
            let { merkleMap } = await merkleMaps();
            // fetch pending actions
            let actionState = await onchainActionState();
            let actions = await fetchMerkleLeaves(internal.contract, {
                fromActionState: actionState,
            });
            let result = await rollup.prove(merkleMap, actions);
            // update internal merkle maps as well
            // TODO make this not insanely recompute everything
            // - take new tree from `result`
            // - update value map in `prove()`, or separately based on `actions`
            let { merkleMap: newMerkleMap, valueMap: newValueMap } = await fetchMerkleMap(height, internal.contract);
            internal._merkleMap = newMerkleMap;
            internal._valueMap = newValueMap;
            return result.proof;
        },
        Proof: rollup.Proof,
        async settle(proof) {
            // verify the proof
            proof.verify();
            // check that proof moves state forward from the one currently stored
            let state = contract().offchainState.getAndRequireEquals();
            Provable.assertEqual(OffchainStateCommitments, state, proof.publicInput);
            // require that proof uses the correct pending actions
            contract().account.actionState.requireEquals(proof.publicOutput.actionState);
            // update the state
            contract().offchainState.set(proof.publicOutput);
        },
        fields: Object.fromEntries(Object.entries(config).map(([key, kind], i) => [
            key,
            kind.kind === 'offchain-field'
                ? field(i, kind.type)
                : map(i, kind.keyType, kind.valueType),
        ])),
        commitments() {
            return State(OffchainStateCommitments.emptyFromHeight(height));
        },
    };
}
OffchainState.Map = OffchainMap;
OffchainState.Field = OffchainField;
OffchainState.Commitments = OffchainStateCommitments;
function OffchainField(type) {
    return { kind: 'offchain-field', type };
}
function OffchainMap(key, value) {
    return { kind: 'offchain-map', keyType: key, valueType: value };
}
//# sourceMappingURL=offchain-state.js.map