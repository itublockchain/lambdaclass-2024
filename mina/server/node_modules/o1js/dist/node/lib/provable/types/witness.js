import { inCheckedComputation, snarkContext, } from '../core/provable-context.js';
import { exists, existsAsync } from '../core/exists.js';
import { TupleN } from '../../util/types.js';
import { createField } from '../core/field-constructor.js';
export { witness, witnessAsync, witnessFields };
function witness(type, compute) {
    let ctx = snarkContext.get();
    // outside provable code, we just call the callback and return its cloned result
    if (!inCheckedComputation() || ctx.inWitnessBlock) {
        return clone(type, type.fromValue(compute()));
    }
    let proverValue = undefined;
    let fields;
    let id = snarkContext.enter({ ...ctx, inWitnessBlock: true });
    try {
        fields = exists(type.sizeInFields(), () => {
            proverValue = type.fromValue(compute());
            let fields = type.toFields(proverValue);
            return fields.map((x) => x.toBigInt());
        });
    }
    finally {
        snarkContext.leave(id);
    }
    // rebuild the value from its fields (which are now variables) and aux data
    let aux = type.toAuxiliary(proverValue);
    let value = type.fromFields(fields, aux);
    // add type-specific constraints
    type.check(value);
    return value;
}
async function witnessAsync(type, compute) {
    let ctx = snarkContext.get();
    // outside provable code, we just call the callback and return its cloned result
    if (!inCheckedComputation() || ctx.inWitnessBlock) {
        let value = await compute();
        return clone(type, value);
    }
    let proverValue = undefined;
    let fields;
    // call into `existsAsync` to witness the raw field elements
    let id = snarkContext.enter({ ...ctx, inWitnessBlock: true });
    try {
        fields = await existsAsync(type.sizeInFields(), async () => {
            proverValue = await compute();
            let fields = type.toFields(proverValue);
            return fields.map((x) => x.toBigInt());
        });
    }
    finally {
        snarkContext.leave(id);
    }
    // rebuild the value from its fields (which are now variables) and aux data
    let aux = type.toAuxiliary(proverValue);
    let value = type.fromFields(fields, aux);
    // add type-specific constraints
    type.check(value);
    return value;
}
function witnessFields(size, compute) {
    // outside provable code, we just call the callback and return its cloned result
    if (!inCheckedComputation() || snarkContext.get().inWitnessBlock) {
        let fields = compute().map((x) => createField(x));
        return TupleN.fromArray(size, fields);
    }
    // call into `exists` to witness the field elements
    return exists(size, () => {
        let fields = compute().map((x) => typeof x === 'bigint' ? x : x.toBigInt());
        return TupleN.fromArray(size, fields);
    });
}
function clone(type, value) {
    let fields = type.toFields(value);
    let aux = type.toAuxiliary?.(value) ?? [];
    return type.fromFields(fields, aux);
}
//# sourceMappingURL=witness.js.map